### 计算机基础知识

#### 文件

文件是外存的概念，只存在于外存中。编程角度可分为可执行文件和不可执行文件

+ 可执行文件：由指令和数据构成
+ 不可执行文件：内容由数据构成

C语言编译链接过程：

```mermaid
graph LR
A(hello.c 源文件)-->|&nbsp&nbsp预编译&nbsp&nbsp|B(hello.i 预编译文件)
B-->|&nbsp&nbsp编译&nbsp&nbsp|C(hello.obj 目标文件)
C-->|&nbsp&nbsp链接&nbsp&nbsp|D(hello.exe 可执行文件)
```

### 数据类型

#### 分类和大小

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **基本类型 ** 整数类型和浮点类型。                           |
| 2    | **枚举类型**                                                 |
| 3    | **void类型**                                                 |
| 4    | **派生类型**  指针类型、数组类型、结构类型、共用体类型和函数类型。 |

##### 整数类型

| 类型           | 存储大小    |
| :------------- | :---------- |
| char           | 1 字节      |
| unsigned char  | 1 字节      |
| signed char    | 1 字节      |
| int            | 2 或 4 字节 |
| unsigned int   | 2 或 4 字节 |
| short          | 2 字节      |
| unsigned short | 2 字节      |
| long           | 4 字节      |
| unsigned long  | 4 字节      |

##### 浮点类型

| float       | 4 字节  |
| ----------- | ------- |
| double      | 8 字节  |
| long double | 16 字节 |

##### void

##### 其它

```sizeof```既是关键字，又是运算符，主要用于计算变量或数据类型所占的字节个数

#### 存储计量的常用表示方式

| 数值  | 大小 |
| ----- | ---- |
| 2^10^ | 1KB  |
| 2^20^ | 1MB  |
| 2^30^ | 1GB  |
| 2^40^ | 1TB  |
| 2^50^ | 1PB  |
| 2^60^ | 1EB  |
| 2^70^ | 1ZB  |
| 2^80^ | 1YB  |
| 2^90^ | 1BB  |



### 常量和变量

#### 标识符

##### 定义

为变量、函数和结构体等起的名称为标识符。

##### 规则

+ 由下划线“_”，英文字母(A-Z,a-z)和数字(0-9)构成，首字符必须是英文字母或者下划线，不能是数字；
+ 命名应尽可能做到见名知意；
+ 关键字不能作为用户标识符；[[C语言关键字及解释]](https://www.jb51.net/article/39926.htm)
+ 一般限制长度为8字符（C89标准限制8字符，C99标准允许长度任意）；
+ 大小写敏感。

#### 变量

变量：即可读，又可写。格式：数据类型 变量名

##### 变量的定义和声明

###### 定义

为当前变量分配一块内存并给它取上一个名字。

###### 声明

+ 告诉编译器当前名字已经匹配到一块内存上
+ 告诉编译器名字已被预订，其它地方无法使用此名字作为变量名

###### 定义与声明的区别

定义创建了对象并为这个对象分配了内存，而声明时没有分配内存空间。

##### 作用域

###### 全局变量

函数外定义的变量

###### 局部变量

函数中定义的变量

###### 程序块中的变量

函数内部复合语句中定义的变量

```c
{
    int a = 0;
}
```

就近原则：向上就近;

###### 注意事项

1. 如果块内定义的变量和在函数中定义的局部变量名字相同时，将隐藏局部变量，使用当前块内定义的变量值

2. ```::``` ==> C++中的作用域解析符

   ```c++
   a::g_max;//声明此处使用全局变量g_max
   ```



#### 常量



### 输入和输出

#### 输入函数

```printf``` ： 一般形式：```printf("格式控制字符串",输出表列)```

格式控制字符串用于指定输出格式，由**格式字符串**和**非格式字符串**两种组成

格式字符串：

| 名称 | 含义               |
| ---- | ------------------ |
| %d   | 按十进制整型输出   |
| %o   | 按八进制整型输出   |
| %x   | 按十六进制整型输出 |
| %c   | 按字符型输出       |
| %ld  | 按字符型输出       |
| %f   | 按浮点数输出       |

#### 输出函数

```scanf```：```scanf("格式控制字符串",输出表列)```

地址表列中给出各变量的地址，由&后加变量名组成。

### 语句

#### 顺序语句

#### 选择语句

#### 循环语句

### 数组

```c
sizeof(ar);//20 整个数组的大小
sizeof(ar[0]);//4 每个数组元素的大小
```

#### 二维数组

##### 定义

```c
int main()
{
    int iar[3][4];//3行4列
    return 0;
}
```



### 函数

#### 函数指针

##### 定义

在程序中定义了一个函数，当编译链接成功，运行程序时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。此时定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。

定义方式： **函数返回值类型 （* 指针变量名）（函数参数列表）**

tips: 比较函数时，不仅要比较函数的**返回类型**是否相同，还要比较函数**参数列表的类型**是否相同。

```c
//调用方法
int Add(int, int);
int Sub(int, int);
int Inc(int);
int main()
{
	int x = 10, y = 20, z = 0;
	z = Add(x, y);
	int(*pfa)(int, int) = NULL;
	pfa = &Add;
	z = (*pfa)(x, y);
	printf("z =  %d", z);
	return 0;
}

int Add(int a, int b) { return a + b; }
int Sub(int a, int b) { return a - b; }
int Inc(int a)
{
	a += 1;
	return a;
}
```

##### 回调函数

```c
//写法二
//typedef int (*PFUN)(int, int);
int Add(int a, int b) { return a + b; }
int Max(int a, int b) { return a > b ? a : b; }
void call_fun(int x, int y, int(*pfun)(int, int))//定义函数指针
//写法二
//void call_fun(int x, int y, PFUN pfun)
{
	if (pfun == NULL) return;
	int z = (*pfun)(x, y);
	printf("z =  %d\n", z);
}
int main()
{
	int x = 10, y = 20;
	call_fun(x, y, Add);
	call_fun(x, y, Max);
    return 0;
}
```





#### 递归函数



### 指针

#### 什么是指针

#### 指针的定义

#### 指针的应用

#### 指针的运算

指针可以 +- n(int) 不可以*/



#### 指针与数组的关系

数组名被看作该数组的第一个元素在内存中的首地址，在表达式中被自动转换为一个指向数组第一个元素的指针常量。数组名是指针，但丢失了数组的大小（数组元素的数量）。编译器按数组定义时的大小分配内存，但运行时对数组的边界不加检测，会导致无法预知的错误。

#### 指针和数组、函数的关系

当数组作为函数的形参时，数组名退化成指针（节省时间和空间）。

```c
/*
    如果调用的函数中实参传入的数组长度无限长，被调用的函数本身的形参此时退化成指针，可以避免占用高内存、运行长时间（时间、空间）的问题。此时如果是int类型的指针数组，则被调用函数在内存中只占用4个字节的空间，用于存放实参首地址。
*/
void Print_Ar(int *br,int n)
{
	int as = sizeof(br);
	int es = sizeof(br[0]);//元素大小
	for (int i = 0; i < n; i++)
	{
		printf("%d\n", br[i]);
	}
}
int main()
{
	int ar[] = { 12,23,34,45,56 };
	int n = sizeof(ar) / sizeof(ar[0]);//array size;
	Print_Ar(ar,n);
	return 0;
}
```



#### 二级指针

一级指针变量指向存储变量的地址，二级指针变量存储一级指针变量的地址。

+ 先确定二级指针本身的值，再确定二级指针指向的值

  ```c
  int a=10, b=20;
  int* p1 = &a;
  int* p2 = NULL;
  int ** s = &p1;
  *s = &a;
  **s = 100;
  s = &p2;
  *s = &b;
  **s = 200;
  ```

  

#### 常见的指针变量

##### 函数返回变量的地址

当一个变量的生存期不受此函数的影响时，就可以通过此函数返回此变量的地址。

```c
int* fun(int* ip)
{
	if (ip != NULL)
	{
		*ip = 100;
	}
	return ip;
}

int main()
{
	int a = 10;
	int* p = &a;//p 是a的地址
	int* s = NULL;
	s = fun(p);
	printf("%d \n",*s);//100
	return 0;
}
```



#####  类型对指针解引用的影响

类型决定了指针变量的2个特性：

+ 
+ 



#### void与void指针变量

##### 无类型指针 void

void不可以定义变量，但可以定义指针变量，void指针可以指向任意类型变量的地址。

C中函数如果没有定义返回类型，系统默认返回int类型。实参是从右向左传递

+ 当函数不需要返回值时，必须使用void限制，如```void fun (int a)```
+ 当函数不允许接受参数时，必须使用void限制，如```int fun (void)```

```c
void fun_a(void)//C中建议写void
{
	printf("fun \n");
	return;
}
```

void是一种抽象类型，不能进行实例化，所以不能定义变量

void* 也不能解引用（可以指向，不能改变）

#### 函数指针

#### 泛型算法

#### 野指针和空指针

定义指针时，如果可以确定某个变量的地址，就在定义指针时对指针进行初始化；如果无法确定指针将指向谁，就在定义时设为NULL，并在后续使用时判断该指针是否为NULL



### 结构体

### 文件

### 关键字

##### const

###### const和define的区别

+ #define是预编译指令，const 是普通变量的定义。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。
+ const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以在编程时使用const和define都可以的情况下尽量使用常变量来取代宏。
+ const定义的本质是变量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样容易出问题，即”边际问题“或者说是”括号问题“。

###### const与指针变量

指针有两个值，一个是自身的值，一个是指向的值。

+ const 在*左边，约束的是指针指向的值

  ```c
  int a = 10, b = 20;
  const int* p1 = &a;
  *p1 = 100;//error=> p1可以指向a的地址，但无法改变a的值
  //可以通过解引用读取 *p1 =>所指向的值，但不可以直接改变*p1所指向的值
  p1 = &b;//但可以改变p1自身的值
  ```

+ const在*右边，约束的是指针自身的值

  ```c
  int a = 10, b = 20;
  int * const p2 = &a;
  *p2 = 100;//此时可以修改指针所指向的值，但不可以修改指针自身的值--const
  p2 = &b;//error 不可修改p2的值，因为被const约束
  ```

+ const同时约束

  ```c
  int a = 10,b = 20;
  const int * const p3 = &a;
  int const * const p3 = &a;//与上方等价
  *p3 = 100;//error 由于const约束，不允许修改p3所指向的值
  p3 = &b;//error 由于const约束，也不允许修改指针p3本身的值
  ```

  

### 多文件结构

#### 多文件结构中的关键字

##### #include

+ #include<> ：编译器会到系统路径下查找头文件
+ #include”” ：编译器首先在当前目录下查找头文件

##### #ifndef

预编译时处理 #endif

#### 计算器

#### 模块化程序设计

#### 函数设计

##### 函数设计的基本原则

+ 封装
  + 调用者（外界）对函数的影响 ——仅限于入口参数
  + 函数对调用者（外界）的影响——仅限于函数的返回值，指针形参。

+ 检查函数的入口参数是否有效合法，检查函数是否调用成功；
+ 函数的规模要小（<80）
+ 函数功能要单一
+ 函数接口的定义要清晰

##### 函数设计的要求

+ 可复用性

+ 可维护性

+ 可读性

  

#### 字符串

##### 字符串检验

+ strlen：返回给定空终止字符串的长度

  ```c
  size_t my_strlen(const char* str);
  ```

+ strcmp：以字典序比较两个空终止字节字符串，结果的符号是比较的字符串中首对不同字符（都转义成unsigned char）的值间的差的符号

  ```c
  int my_strcmp(const char *lhs, const char *rhs);
  ```

+ strncmp：比较两个可能空终止的数组的最多count个字符，按字典序进行比较。不比较后随空字符的字符。结果的符号是被比较的数组中首对字符（都转义成unsigned char）的值间的差的符号。

  ```c
  int my_strncmp(const char *lhs ,const char *rhs,size_t count);
  ```

+ strcha：查找字符的首次出现

  ```c
  char *my_strchr(const char *str,int ch);
  ```

+ strrchr：查找字符的最后一次出现

  ```c
  char *my_strrchr(const char *str,int ch);
  ```

+ strstr：查找子串字符的首次出现

  ```c
  char *my_strstr(const char* str,const char* substr);
  ```

  

##### 字符串操作

+ strcpy：复制一个字符串给另一个
+ strncpy：从一个字符串复制一定数量的字符到另一个
+ strcat：连接两个字符串



##### 内存操作函数

```c
void my_memset(void* vp, unsigned char ch, size_t count)
{
	unsigned char* cp = (unsigned char*)vp;
	for (int i = 0; i < count; i++)
	{
		*cp = ch;
		cp = cp + 1;
	}
}
int main()
{
    //1
	/*
        int ar[10];
        my_memset(ar, 10, sizeof(ar));
        for (int i = 0; i < 10; i++)
        {
            printf("%d \n", ar[i]);
        }
	*/
    //2
    char str[10];
	my_memset(str, 'a', sizeof(str));
	for (int i = 0; i < 10; i++)
	{
		printf("%d \n", str[i]);//97
	}
	return 0;
}
```

